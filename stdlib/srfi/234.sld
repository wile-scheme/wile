(define-library (srfi 234)
  (import (scheme base) (scheme case-lambda))
  (export topological-sort edgelist->graph
          edgelist/inverted->graph graph->edgelist
          graph->edgelist/inverted connected-components)
  (begin
    ;; A graph is ((node . (successor ...)) ...)
    (define (topological-sort graph . rest)
      (let ((eq (if (null? rest) equal? (car rest))))
        (let* ((nodes (map car graph))
               (in-degree (map (lambda (n) (cons n 0)) nodes)))
          ;; Count in-degrees
          (for-each (lambda (entry)
            (for-each (lambda (succ)
              (let ((p (%assoc succ in-degree eq)))
                (when p (set-cdr! p (+ (cdr p) 1)))))
              (cdr entry)))
            graph)
          ;; Collect zero in-degree nodes
          (let loop ((queue (filter (lambda (p) (= (cdr p) 0)) in-degree))
                     (result '())
                     (remaining (filter (lambda (p) (> (cdr p) 0)) in-degree)))
            (if (null? queue)
                (if (null? remaining)
                    (reverse result)
                    (error "topological-sort: cycle detected"))
                (let* ((node (caar queue))
                       (succs (let ((e (%assoc node graph eq)))
                                (if e (cdr e) '())))
                       (new-remaining
                         (map (lambda (p)
                           (if (%member (car p) succs eq)
                               (cons (car p) (- (cdr p) 1))
                               p))
                           remaining))
                       (new-queue (filter (lambda (p) (= (cdr p) 0)) new-remaining))
                       (still-remaining (filter (lambda (p) (> (cdr p) 0)) new-remaining)))
                  (loop (append (cdr queue) new-queue)
                        (cons node result)
                        still-remaining)))))))

    (define (filter pred lst)
      (let loop ((lst lst) (acc '()))
        (cond ((null? lst) (reverse acc))
              ((pred (car lst)) (loop (cdr lst) (cons (car lst) acc)))
              (else (loop (cdr lst) acc)))))

    (define (%member x lst eq)
      (cond ((null? lst) #f)
            ((eq x (car lst)) lst)
            (else (%member x (cdr lst) eq))))

    (define (%assoc key alist eq)
      (cond ((null? alist) #f)
            ((eq key (caar alist)) (car alist))
            (else (%assoc key (cdr alist) eq))))

    (define (edgelist->graph edges . rest)
      (let ((eq (if (null? rest) equal? (car rest))))
        (let loop ((edges edges) (graph '()))
          (if (null? edges) graph
              (let* ((edge (car edges))
                     (from (car edge))
                     (to (cadr edge))
                     (entry (%assoc from graph eq)))
                (if entry
                    (begin (set-cdr! entry (cons to (cdr entry)))
                           (loop (cdr edges) graph))
                    (loop (cdr edges) (cons (list from to) graph))))))))

    (define (edgelist/inverted->graph edges . rest)
      (let ((eq (if (null? rest) equal? (car rest))))
        (apply edgelist->graph
          (map (lambda (e) (list (cadr e) (car e))) edges)
          rest)))

    (define (graph->edgelist graph)
      (let loop ((g graph) (acc '()))
        (if (null? g) acc
            (let ((node (caar g)) (succs (cdar g)))
              (loop (cdr g)
                    (append acc (map (lambda (s) (list node s)) succs)))))))

    (define (graph->edgelist/inverted graph)
      (map (lambda (e) (list (cadr e) (car e)))
           (graph->edgelist graph)))

    (define (connected-components graph . rest)
      (let ((eq (if (null? rest) equal? (car rest))))
        (let ((all-nodes (map car graph))
              (visited '())
              (components '()))
          (define (neighbors node)
            (let ((e (%assoc node graph eq)))
              (if e (cdr e) '())))
          (define (dfs node component)
            (unless (%member node visited eq)
              (set! visited (cons node visited))
              (set! component (cons node component))
              (for-each (lambda (n) (set! component (dfs n component)))
                        (neighbors node)))
            component)
          (for-each (lambda (node)
            (unless (%member node visited eq)
              (let ((comp (dfs node '())))
                (set! components (cons comp components)))))
            all-nodes)
          components)))))
